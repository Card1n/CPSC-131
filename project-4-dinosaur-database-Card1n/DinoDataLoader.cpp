
/**
 * DO NOT EDIT THIS FILE
 */

#include "DinoDataLoader.hpp"
#include "Randomer.hpp"


#include <fstream>
#include <iostream>
#include <memory>
#include <string>
#include <sstream>
#include <vector>


using CPSC131::Randomer;

using std::cout, std::endl;
using std::ifstream;
using std::string;
using std::stringstream;


namespace CPSC131::Databases::Dinosaurs
{
	//
	DinoDataLoader::DinoDataLoader()
	{
		cout << "DinoDataLoader::CTOR()" << endl;
		
		cout << "File name is: " << this->data_filename_ << endl;
		
		this->rng_ = std::default_random_engine(this->random_device_());
	}
	
	void DinoDataLoader::loadDinosaursToTree
	(
		DinoTree& tree,
		size_t count,
		unsigned int seed
	)
	{
		//
		Randomer randomer;
		
		//
		if ( seed != 0 ) {
			randomer.setSeed(seed);
		}
		
		//	Load the CSV
		cout << "Begin loading from CSV" << endl;
		std::unique_ptr<std::vector<Dinosaur>> dinos = this->loadCSV();
		cout << "Finished loading " << dinos->size() << " dino records from the CSV" << endl;
		
		//	Determine the highest existing ID so we can start one higher
		size_t next_id = 0;
		tree.traverseInOrder
		(
			[&next_id](DinoTree& t, std::shared_ptr<DinoTree::Node> node) -> bool
			{
				//
				auto dino = node->getData();
				if ( dino.getID() > next_id ) {
					next_id = dino.getID();
				}
				
				return true;
			}
		);
		next_id++;
		
		//	We now have data loaded from the CSV.
		//	Let's randomly grab dinosaurs from the CSV vector (allowing duplicates)
		//	while giving them sequential IDs,
		//	to make the data more interesting.
		std::vector<Dinosaur> dinos_list;
		cout << "Inserting dinosaur entries into a temporary vector ";
		for ( size_t i = 0; i < count; i++ ) {
			
			size_t index = randomer.size_type(0, dinos->size() - 1);
			
			auto dino = dinos->at(index);
			
			//	We'll make sure all IDs are sequential within the tree,
			//	ignoring whether they match a specific Dino on previous/future runs
			dino.setID(next_id++);
			
			dinos_list.push_back(dino);
			
			if ( i % ITERATIONS_PER_DOT == 0 ) {
				cout << "." << std::flush;
			}
		}
		cout << endl;
		cout << "Finished inserting dinosaur entries into a temporary vector" << endl;
		
		//	Randomize the list so this new tree is faster than linear time
		cout << "Shuffling the temp vector" << endl;
		std::shuffle(dinos_list.begin(), dinos_list.end(), randomer.getGenerator());
		cout << "Finished shuffling the temp vector" << endl;
		
		//	Insert to the binary search tree, woot
		cout << "Inserting shuffled dinosaur entries into binary search tree ";
		for ( size_t i = 0; i < dinos_list.size(); i++ ) {
			
			auto& dino = dinos_list[i];
			tree.insert(dino);
			
			if ( i % ITERATIONS_PER_DOT == 0 ) {
				cout << "." << std::flush;
			}
		}
		cout << endl;
		cout << "Finished inserting dinosaur entries into binary search tree" << endl;
	}
	
	std::unique_ptr<std::vector<Dinosaur>> DinoDataLoader::loadCSV()
	{
		ifstream f(this->data_filename_);
		std::unique_ptr<char> buffer(new char[BUFFER_SIZE]);
		std::unique_ptr<std::vector<Dinosaurs::Dinosaur>> dinos(new std::vector<Dinosaurs::Dinosaur>);
		
		size_t dino_id = 0;
		while ( true )
		{
			f.getline(buffer.get(), BUFFER_SIZE);
			if ( f.eof() ) {
				cout << "End of data reached" << endl;
				break;
			}
			else if ( f.fail() ) {
				throw std::logic_error("Buffer size is too small for this database");
			}
			
			else{
				stringstream ss(buffer.get());
				Dinosaurs::Dinosaur dino;
				
				//	Oh my goodness
				dino.setID(dino_id++);
				dino.setName(this->loadCSVColumn(ss, 0));
				dino.setDiet(this->loadCSVColumn(ss, 1));
				dino.setPeriod(this->loadCSVColumn(ss, 2));
				dino.setLivedIn(this->loadCSVColumn(ss, 3));
				dino.setType(this->loadCSVColumn(ss, 4));
				dino.setLength(this->loadCSVColumn(ss, 5));
				dino.setTaxonomy(this->loadCSVColumn(ss, 6));
				dino.setNamedBy(this->loadCSVColumn(ss, 7));
				dino.setSpecies(this->loadCSVColumn(ss, 8));
				
				string link;
				ss >> link;
				dino.setLink(link);
				
				dinos->push_back(dino);
				
				// cout << dino.toString() << endl;
			}
		}
		
		return dinos;
	}
	
	string DinoDataLoader::loadCSVColumn(stringstream& ss, size_t index)
	{
		std::unique_ptr<char> buffer( new char [BUFFER_SIZE] );
		
		ss.getline(buffer.get(), BUFFER_SIZE, ',');
		
		if ( ss.fail() ) {
			throw std::logic_error(
				"Failed to parse CSV line at column "
				+ std::to_string(index) + ": "
				+ buffer.get()
			);
		}
		else if ( ss.eof() ) {
			throw std::logic_error(
				"Ran out of data trying to parse CSV line at column "
				+ std::to_string(index) + ": "
				+ buffer.get()
			);
		}
		else {
			// cout << "|||" << buffer << endl;
		}
		
		return std::string(buffer.get());
	}
}



